{% extends "base.html" %}

{% block title %}Dev Blog{% endblock %}

{% block styles %}
    <link rel="stylesheet" href="{{ url_for('static', filename='css/main.css') }}">
{% endblock %}

{% block scripts %}
    <script src="{{ url_for('static', filename='js/glow.js') }}"></script>
    <script src="{{ url_for('static', filename='js/neonStart.js') }}"></script>
{% endblock %}

{% block content %}
    <div class="blog-content">
        <h2 class="neon-effect">Blog</h2>
        <article>
            <h2>First Post! March 20, 2024</h2>
            <p>The first post for this blog, I want to set some expectattions. First of all, if you are here in the early stages, thank you for reading! Second, I would like to acknowledge that you are seeing plain, open text at the top of an empty page. Pretty boring right now, right? Worry not, I have plans for this page. When I'm finished with it, I plan on making it worthy of being on my projects page. Stay tuned for more!</p>
            <p>Another point I would like to make is that these words are all my own. I will not use AI to produce a blog entry. Let's extend that and say that none of the writing in my portfolio will be produced by AI. I will say that in my more formal writing, I will run it through AI to check for spelling and grammar errors, but it is not going to be produced by anything except my brain. A little sad that I have to address this point, but it's the world we live in, isn't it?</p> 
            <p>My formal writing up to this point has been for school, BUT, I have found that I learn more about theory from researching and writing a tech subject than I do from any other method. So letting AI spit out that content from me would be pointless. This blog will personal reflections on my journey, so why would I assign that to a lifeless AI? Again, that would be pointless.</p>
            <p>The content of this blog will be mostly informal, sometimes downright casual. And yes, there will probably be some typos that I don't catch. Welcome to the journey!</p>
        </article>
        <article>
            <h2>March 27, 2024</h2>
            <p>I think one of the themes that I want to write about consistently should be called "The stuff they don't teach you in school." I'll be honest, &quot;stuff&quot; isn't my first choice of words, but I'll keep this family friendly even though I never expect kids to read it. Mom might read it one day (Hi Mom!).</p>
            <p>Austin Community College has unique programs for the tech industry where they give associate degrees in tech by loading four semesters full of tech classes instead of the customary "basics" that most college students take their freshman and sophomore year. My only English class was technical writing. My plan required me to take one arts class, one history or government class, one speech class and one algebra class but I already have a bachelors degree and they counted previous work. Point is, you don't take much in the "normal" workload and instead take a tech intensive path. Out of the sixty required class hours, all but 15 are tech.</p>
            <p>At this point, I need to recognize that this isn't the normal course, so maybe my theme needs to be "The stuff they didn't teach ME in school." Meh, whatever. Point is, as I embark on this journey, I'm discovering that there is a lot of stuff that they just kind of gloss over assuming you'll get it when you get a job. And yet, with the current state of the tech industry, there is no guarantee that you will get a job. I'm going into the post graduation world with the idea that I might be freelancing for awhile and, if that is the case, I'm ready to embrace it.</p>
            <p>The very first thing I ran across in the "stuff they don't teach you?" Those pesky .htaccess files. I had one professor tell me that they should absolutely not EVER be included in your git commits, but that is it. Period. So now I'm wondering if a bootcamp would cover such a simple thing. Does a four year CS degree cover it? It occurs to me that I should explain what a .htaccess file is,so if you need that explanation, check next week's blog post.</p>
            <p>When I put the CSS Dallas website into production, I quickly discovered that all Apple devices labelling my website "insecure" even though it had a valid SSL certificate. Android phone showed it as secure. It was secure on PCs. You know the worst part? Liquid Web's documentation didn't have anything about on the first two pages of my search results, and Stack Overflow had a lot of answers that were just plain wrong. I had to lean on an experienced Sys Admin who was nice enough to do his own looking into the situation and found the solution. I was trying to write a redirect for the .htaccess file to force all products to redirect to HTTPS instead of HTTP; Simple, right? Well, I was having the redirect check the request itself (RewriteCond %{HTTPS} !on [NC]), as every answer on the internet that I could find was telling me to do some version of this. Turns out, with the Liquid Web sites, the redirect needed to check the environmental variable {ENV: HTTPS} instead. And POOF, everything worked. The client really wanted their website to show secure, so that simple little line inside that file caused hours of heartache...not my first rodeo with the techache.</p>
            <p>Already, that is not the last "stuff" situation that I've encountered, but I'll leave that for a future post.</p>
        </article>
        <article>
            <h2>April 2, 2024</h2>
            <p>As promised, I'm going to cover the .htaccess file with this post. Now, obviously I've had a few rounds with this subject, but I felt it was going to be pretty important that I do some research to ensure I know what I'm talking about and make sure I cover the subject quickly, but adequately. So not all over these words are directly mine, but a result of looking up the subject of the mighty .htaccess file.</p>
            <p>The .htaccess file is a configuration file used by web servers running Apache software. It sets many of "the rules" for your server. The most common use for the file is website redirects (such as my case where I wanted to redirect any HTTP request to HTTPS, the secure site) and improve security. In shared hosting (a common hosting option), you will put your .htaccess file in the main, or root, directory. Something I've just learned: the name stands for "hypertext access," and it can control some really important aspects of how your website interacts with a visitor's browser.</p>
            <p>Now, let me pause real quick and cover something else that I did not really know up until tonight. Let's go back to the first sentence of that last paragraph (don't really go back, keep reading, just think back), the one that says "used by web servers running Apache software." In school we were taught on the LAMP stack (Linux, Apache, MySQL, PHP), so I had seen a .htaccess file in every webpage that I had put up. I didn't put them there, it was one of those 'magically there' things - it just 'was.' And with school focusing solely on the LAMP stack, I've never used Nginx. As a matter of fact, I've only known that it was pronounced "engine x" for the past few weeks. So I had no idea how Nginx worked. Learning that it does not use .htaccess, but instead covers the issues in the main configuration file or in specific server block files, was interesting. I went down a small rabbit hole, but had to pull myself out fairly quickly to complete this post. From what I read, this put Nginx in the "steeper learning curve" category, but offsets the pain with a streamlined way to manage your server configurations.</p>
            <p>So obviously not all .htaccess files are created equally and mine wanted to be a unique butterfly. I wrote so many configurations of the same thing that "doing something over and over and expecting a different result" might apply in this situation. Thing is, I learned a ton. And I learned that, yes, there is an article in Liquid Web's documentation that correctly demonstrates the solution to my problem. It's a lot easier to search for something when you already know the outcome. So if you are using Apache, this little file is a powerful tool and it is really important to work out the specific requirements for your server. The nice thing is, once you know...you have the power in your hands.</p>
            <p>And that being said, I'm going to move to yet another direction. I guess I should have realized that Nginx would not necessarily use .htaccess files, as I had already discovered that Caddy doesn't use them either. This very website that you are reading is running on Caddy rather than Apache or Nginx, and let me tell you...Caddy? It just works. Well, that might be a little disingenuous considering I'm stealing that "it just works" from many, many online discussions about Caddy, but everyone seems to have the same opinion. And also disingenuous because I became convinced fairly quickly, but not immediately. What? Why not immediately? Oh, in the "stuff they don't teach" category, even on a VPS where many customers are quite likely using it to host websites, you still have to "ufw allow 80" and "ufw allow 443" (Linux commands to open ports). Yeah, open the ports that are used to make HTTP and HTTPS requests dummy! Nothing, not even Caddy, is going to work on a website until you open those ports! It makes me smile now, I'm learning.</p>
        </article>
        <article>
            <h2>April 11, 2024</h2>
            <p>I wanted to go back and talk about Caddy some more. To prepare, I went to the Caddy documentation, so I’ll share the heading. “Welcome to Caddy. Caddy is a powerful, extensible platform to serve your sites, services, and apps, written in Go. If you’re new to Caddy, the way you serve the Web is about to change.”</p>
            <p>So, let's start there. They are not lying. Having Apache pushed on me from the beginning of school, Caddy came as a pleasant surprise. All you have to do to see the truth is watch a tutorial about setting up a virtual private server with Apache HTTPS web server software and then watch a tutorial about setting up Caddy web server software. The number of things that Caddy does for you is really, really nice. The Caddy documentation at caddyserver.com/docs has a getting started tutorial that covers the basics of downloading and, as it says, getting started. It takes you through config files, APIs, JSON, and the Caddyfile, giving good comparison lists to show you what is easy and what is difficult, giving you the choice of direction.</p>
            <p>Configuration files are optional with Caddy, but they run you through how to set one up first. The docs explain that Caddy’s configuration is a JSON document at its core and runs you through a “hello world” file. The docs then explain how a multi-line config file (19 lines if you include a string of closing brackets) can be done in two lines with a Caddyfile. That, right there, sums up the Caddy experience. If you let Caddy do what Caddy does, it is simplicity compared to other methods. Like magic.</p>
            <p>There is a post on the internet that is titled “Caddy seems too good to be true? I just set it up.” Is it too good to be true? I’ve delved into some of the good and some of the bad. To begin with, a great thing about Caddy is that it was the first web server that used HTTPS by default. When you start your website, Caddy will automatically connect to Let’s Encrypt and configure your SSL certificate for you. Even better? It will automatically renew it as well.</p>
            <p>Other benefits of Caddy include a plugin system that allows you to build on its functionality, giving you options for many use cases and allowing you options to scale. Built-in support for load balancing is a thing with Caddy. Reverse Proxy, serving Markdown files and HTTP/2 and QUIC support are all in Caddy’s lane. Additionally, it can be used on many different environments including Linux, Windows, MacOS, Cloud computing, Docker, Kubernetes, and even WordPress, Drupal, and Joomla.</p>
            <p>So, what’s the downside? For one, it was released in 2015, so it’s a relatively newcomer. At the moment, it has a tiny sliver of the market share, so its community is also small compared to the big guys. A smaller community means fewer independent tutorials on the internet, less help on the boards, and just an overall much smaller presence. Another natural extension of a smaller community is a smaller library of extensible modules than Apache or Nginx. Being newer, and having a smaller slice, it just hasn’t proven itself and hasn’t built the trust that comes with seasoned pros like Apache and Nginx.</p>
        </article>
    </div>
{% endblock %}